# 1.4. 依赖

典型的企业应用程序不会只有一个对象（或Spring术语中的bean）。即使是最简单的应用程序也有一些对象一起工作，最终呈现给用户。

下一节将解释如何从定义一些独立的bean到一个真实的应用程序，在该应用程序中通过对象协作来实现一个目标。

## 1.4.1. 依赖注入

依赖项注入（DI）是指：对象仅仅通过构造函数参数、工厂方法的参数或从工厂方法构造,或返回对象实例后在其上设置属性来定义其依赖项（即它们使用的其他对象）。然后，容器在创建bean时注入这些依赖项。这个过程基本上和bean通过直接类的构造器或服务定位器来定位其依赖的过程是相反的（因此称为控制反转）。

使用DI，代码更干净，当对象具有依赖关系时，去耦更有效。对象不需要查找其依赖项，甚至不知道依赖项的位置或类。
因此，您的类变得更容易测试，特别是当依赖于接口或抽象基类时。（允许在单元测试中使用stub或mock实现）


DI有两个主要的方式：基于构造函数的依赖注入和基于setter的依赖注入。


**基于构造函数的依赖注入**

基于构造函数的DI是通过容器调用带有多个参数的构造函数来实现的，每个参数表示一个依赖项。这个和调用带有特定参数的静态工厂方法来构造bean几乎是等效的，这里将会对构造函数和静态工厂方法的参数做相似的处理。下面的示例显示了一个只能通过构造函数注入依赖项的类：

```
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

注意这个类没有什么特别的。它是一个POJO，不依赖于特定于容器的接口、基类或注释。

**构造函数参数的解析**

一般通过参数的类型来进行构造函数参数的解析匹配。如果bean定义的构造函数参数中没有潜在的歧义，那么在bean定义中定义构造函数参数的顺序就是在bean被实例化时，这些参数被提供给适当的构造函数的顺序。可以看下面的类：


```
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

假设ThingTwo和ThingThree类与继承无关，则不存在潜在的歧义。因此，以下配置工作正常，您不需要在<constructor-arg/>元素中显式指定构造函数参数索引或类型。

```
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

当引用另一个bean时，如果类型是已知的，可以通过类型进行匹配（前面的例子就是这样）。当使用简单类型时，例如<value>true</value>，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型匹配。考虑以下情况：


```
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private int years;

    // The Answer to Life, the Universe, and Everything
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

**构造函数类型匹配**

在前面的场景中，如果使用type属性显式指定构造函数参数的类型，则容器可以使用与简单类型匹配的类型。如下示例所示：


```
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

**构造函数索引**

你也可以使用index属性来显示的指定构造函数参数的位置，如下所示：


```
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

除了解决多个简单值的不确定性之外，指定索引还可以解决构造函数有两个相同类型参数的不确定性。


```
注意：index是从0开始的。
```


**构造函数名字匹配**

你也可以使用构造函数的参数名字来指定，如下所示：

```
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

请记住，要使用这项功能，必须在启用调试标志的情况下编译代码，以便Spring可以从构造函数中查找参数名。

如果无法或不希望使用调试标志编译代码，可以使用@ConstructorProperties JDK注释显式命名构造函数参数。然后示例类必须如下所示：


```
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

**基于Setter的注入依赖**

基于Setter的DI是由容器在调用无参数构造函数或无参数静态工厂方法实例化bean之后调用bean上的setter方法来完成的。

下面的示例显示了一个类，该类只能通过使用纯setter注入来注入依赖项。这个类是传统的Java。它是一个POJO，不依赖于特定于容器的接口、基类或注释。


```
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

ApplicationContext支持它所管理的bean的基于构造函数和基于setter的DI。在通过构造函数方法注入了一些依赖项之后，仍然可以使用基于setter的DI。
所有的依赖都会被转化成为BeanDefinition，它会与PropertyEditor实例一起使用，将属性从一种格式转换为另一种格式。
然而，大多数Spring用户并不直接使用这些类（即代码编程方式），而是使用XML bean定义、注解的组件（即用@Component、@Controller等来注解的类），或基于Java的@Configuration注解中的@Bean方法。然后，这些定义会在内部转换为BeanDefinition实例，并被用于Spring IOC容器中。


```
构造函数还是setter形式的注入？

由于您可以混合使用基于构造函数和基于setter的DI，所以对于强制依赖项使用构造函数，对于可选依赖项使用setter方法或配置方法是一个很好的实践经验。
注意，可以使用setter方法上的@Required注解使属性成为必需的依赖项；但是，最好使用构造函数注入并在程序中做相应的验证。

Spring团队通常提倡构造函数注入，因为它允许您将应用程序组件实现为不可变的对象，并确保所需的依赖项不为空。此外，构造函数注入的组件总是以完全初始化的状态返回到客户端（调用）代码。另一点需要注意的是，大量的构造函数参数是一种糟糕的代码体验，这意味着类可能做了太多的事情，应该重构以做适当的分离。

Setter注入应该主要用于可在类内分配合理默认值的可选依赖项。否则，在代码使用依赖项的任何地方都必须执行非空检查。Setter注入的一个好处是Setter方法使该类的对象能够在以后重新配置或重新注入。因此，通过JMX MBeans进行管理是Setter注入的一个成功的用例。

对特定类使用最有意义的DI样式。有时，在处理没有源代码的第三方类时，只有一种选择。例如，如果第三方类不公开任何setter方法，那么构造函数注入可能是DI的唯一可用形式。

```












